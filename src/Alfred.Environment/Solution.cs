using System.Reflection;

using CliWrap;

namespace Maid.Environment
{
    /// <summary>
    /// The class that handles anything involving the solution and its prerequisites and miscellaneous files.
    /// </summary>
    public sealed class Solution
    {
        private const string CONFIG_NAME = ".alfred";
        private const string OBJECT_DIR_NAME = ".alfredobj";
        private readonly FileInfo _configFile;
        private Configuration? _configuration;

        public Solution(string sourceDir)
        {
            Source = new(sourceDir);
            ObjectDir = Source.Combine(OBJECT_DIR_NAME);
            _configFile = Source.CombineToFile(CONFIG_NAME);

            if (!Source.Exists)
            {
                Source.Create();
            }

            if (!ObjectDir.Exists)
            {
                ObjectDir.Create();
                ObjectDir.Attributes = FileAttributes.Directory | FileAttributes.Hidden;
            }
        }

        public Configuration Configuration
        {
            get
            {
                if (_configuration == null)
                {
                    return _configuration = Configuration.Read(_configFile.FullName);
                }
                else
                {
                    return _configuration;
                }
            }
        }

        public bool HasConfiguration => _configFile.Exists;

        public DirectoryInfo Source
        {
            get;
            init;
        }

        /// <summary>
        /// The object directory where all the metadata used or/and generated by Maid are stored.
        /// </summary>
        private DirectoryInfo ObjectDir
        {
            get;
            init;
        }

        public static void Save(string path, string content)
        {
            if (!File.Exists(path))
            {
                SaveUnsafe(path, content);
            }
        }

        /// <summary>
        /// Saves the file to the <see cref="ObjectDir">object directory</see>.
        /// </summary>
        /// <remarks>
        /// The underlying save-method uses <see cref="SaveUnsafe(string, string)"/>.
        /// </remarks>
        public static void SaveObject(string path, string content) => SaveUnsafe(path, content);

        /// <summary>
        /// Overwrites the content if it exists.
        /// </summary>
        public static void SaveUnsafe(string path, string content) => File.WriteAllText(path, content);

        /// <summary>
        /// Maid's prerequisites.
        /// </summary>
        public void CreatePrerequisites()
        {
            var script = Source.CombineToFile("build.ps1");

            // Create build.ps1
            SaveResource(script.FullName, script.Name);

            // Create .maid
            Configuration.CreateXml(_configFile.FullName,
                                    Path.GetRelativePath(Source.FullName, script.FullName));
        }

        public void CreateSolution(string name, string output)
        {
            var buildProps = Source.CombineToFile("Directory.Build.props");

            // Create solution
            _ = Cli.Wrap("dotnet")
                   .WithArguments($"new sln -n {name} -o \"{output}\" ")
                   .ExecuteAsync()
                   .GetAwaiter()
                   .GetResult();

            // Create Directory.Build.props
            SaveResource(buildProps.FullName, buildProps.Name);

            Restore();
        }

        public void Restore()
        {
            var resources = new Dictionary<string, string>()
            {
                {
                    "Sdk.props",
                    Path.Combine(ObjectDir.FullName, "Sdk.props")
                }
            };

            foreach (var (Key, Value) in resources)
            {
                if (!File.Exists(Value))
                {
                    SaveResource(Value, Key);
                }
            }
        }

        public static string ReadResource(string resName)
        {
            var @this = Assembly.GetExecutingAssembly();
            resName = $"{@this.GetName().Name}.Resources.{resName}";

            using var stream = @this.GetManifestResourceStream(resName).ShouldNotBeNull();
            using var reader = new StreamReader(stream);

            return reader.ReadToEnd();
        }

        private static void SaveResource(string path, string resName) => Save(path, ReadResource(resName));
    }
}